#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <libopencmsis/core_cm3.h>

#include "util.h"
#include "wifi.h"

// wifi_rb is the ring buffer that receives all incoming data from the WIFI
// module, data is written to it during an interrupt on the USART and read from
// it in the wifi sys tick handler.
uint8_t wifi_rb_space[RING_BUFF_SIZE];
ring_buffer_t wifi_rb = {wifi_rb_space, 0, 0, 0};

// tmp_buffer is used to process WIND from the WIFI module.
uint8_t tmp_buffer[WIFI_TMP_BUFF_SIZE];

// spwf_at_state is the global state for the current AT command, state will be
// reset before executing a new AT command.
uint8_t at_buff_space[WIFI_AT_BUFF_SIZE];
ATState spwf_at_state = {AT_STATUS_CLEAR, &at_buff_space[0], 0, 0};

// spwf_state tracks the current state of the WIFI module.
volatile SpwfState spwf_state = SPWF_STATE_OFF;

// spwf_recv_state tracks the expected response type from the WIFI module, it is
// used to decide what kind of processing is done on the response.
static RecvType spwf_recv_state = RECV_ASYNC_INDICATION;

static void wifi_SetupGPIO(void);
static void wifi_SetupUSART(void);

bool spwf_ProcessAsyncIndication(uint8_t *const buff, uint8_t data);
bool spwf_ProcessWIND(SpwfState *state, uint8_t *const buff_ptr);
bool wifi_ProcessCIND(Config *c, uint8_t *const buff);
bool spwf_ProcessATResponse(ATState *at, uint8_t data);
uint16_t wifi_http_parse_status(uint8_t *response);
static void spwf_DebugPrintBuffer(uint8_t *const buff, uint8_t prefix);

unsigned char index_html[];
unsigned int index_html_len;
unsigned char json_header[];

void wifi_Init(void) {
  wifi_SetupGPIO();
  wifi_SetupUSART();
  spwf_PowerOn();
}

void spwf_PowerOn(void) {
  gpio_set(GPIOB, GPIO2);  // Power on Wifi module.
}

void spwf_PowerOff(void) {
  gpio_clear(GPIOB, GPIO2);  // Power off Wifi module.
}

// spwf_SoftReset executes the AT+CFUN command, issuing a reset, and waits for
// the power on indication from the WIFI module.
void spwf_SoftReset(void) {
  // We must wait for the console to be active.
  spwf_WaitState(SPWF_STATE_CONSOLE_ACTIVE);

  // Unset the power on state so that we can wait for it.
  spwf_state &= ~(SPWF_STATE_POWER_ON);

  spwf_SendString("AT+CFUN=1\r");  // Reset wifi module.
  spwf_WaitState(SPWF_STATE_POWER_ON);
}

void spwf_HardReset(void) {
  spwf_PowerOff();
  spwf_state = SPWF_STATE_OFF;
  delay(1000);
  spwf_PowerOn();
  spwf_WaitState(SPWF_STATE_POWER_ON);
}

static void wifi_SetupGPIO(void) {
  rcc_periph_clock_enable(RCC_WIFI_USART);

  gpio_mode_setup(WIFI_GPIO_PORT, GPIO_MODE_AF, GPIO_PUPD_NONE, WIFI_GPIO_TX);
  gpio_set_output_options(WIFI_GPIO_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_10MHZ,
                          WIFI_GPIO_TX);

  gpio_mode_setup(WIFI_GPIO_PORT, GPIO_MODE_AF, GPIO_PUPD_NONE, WIFI_GPIO_RX);
  gpio_set_output_options(WIFI_GPIO_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_10MHZ,
                          WIFI_GPIO_RX);

  gpio_set_af(WIFI_GPIO_PORT, GPIO_AF7, WIFI_GPIO_TX);
  gpio_set_af(WIFI_GPIO_PORT, GPIO_AF7, WIFI_GPIO_RX);
}

static void wifi_SetupUSART(void) {
  usart_set_baudrate(WIFI_USART, 115200);
  usart_set_databits(WIFI_USART, 8);
  usart_set_stopbits(WIFI_USART, USART_STOPBITS_1);
  usart_set_mode(WIFI_USART, USART_MODE_TX_RX);
  usart_set_parity(WIFI_USART, USART_PARITY_NONE);
  usart_set_flow_control(WIFI_USART, USART_FLOWCONTROL_NONE);

  nvic_enable_irq(WIFI_NVIC_IRQ);

  // Give lower priority to SYSTICK IRQ than to WIFI USART IRQ so that we can
  // keep pushing data into the ring buffer even when wifi_SysTickHandler is
  // processing.
  nvic_set_priority(NVIC_SYSTICK_IRQ, (1 << 4));
  nvic_set_priority(WIFI_NVIC_IRQ, (0 << 4));

  usart_enable_rx_interrupt(WIFI_USART);

  usart_enable(WIFI_USART);
}

void spwf_SendString(const char *str) {
  while (*str) {
    usart_send_blocking(WIFI_USART, *str++);
  }
}

// wifi_SysTickHandler consumes the wifi ring buffer and processes it
// according to the current spwf_recv_state. Only one char is processed per
// tick, except when AT_STATUS_FAST_PROCESS is enabled.
void wifi_SysTickHandler(void) {
  uint8_t data;
  bool status;

process_loop:
  // Temporarily disable interrupts, ring buffer is not thread safe.
  __disable_irq();
  data = ring_buffer_pop(&wifi_rb);
  __enable_irq();

  if (data != '\0') {
    switch (spwf_recv_state) {
      // Asynchronous indications can happen at any point except when an AT
      // command is processing, this is the default spwf_recv_state.
      case RECV_ASYNC_INDICATION:
        status = spwf_ProcessAsyncIndication(&tmp_buffer[0], data);

        if (status == SPWF_PROCESS_COMPLETE) {
          bool is_wind = spwf_ProcessWIND(&spwf_state, &tmp_buffer[0]);

          if (!is_wind && !wifi_ProcessCIND(&config, &tmp_buffer[0])) {
            printf("Could not process asynchronous indication\n");
          }

          memset(&tmp_buffer[0], 0, WIFI_TMP_BUFF_SIZE);
        }

        break;
      // AT command responses only happen after an AT command has been issued,
      // some only return OK / ERROR whereas others have a response body, ending
      // with OK / ERROR.
      case RECV_AT_RESPONSE:
        status = spwf_ProcessATResponse(&spwf_at_state, data);
        if (status == SPWF_PROCESS_COMPLETE) {
          spwf_recv_state = RECV_ASYNC_INDICATION;
        } else if ((spwf_at_state.status & AT_STATUS_FAST_PROCESS) != 0) {
          goto process_loop;
        }
        break;
      // Unhandled recv state.
      default:
        printf("Unknown spwf_recv_state\n");
        break;
    }
  }
}

// WIFI_isr handles interrupts from the WIFI module and stores the data in a
// ring buffer.
void WIFI_isr(void) {
  if (usart_get_flag(WIFI_USART, USART_SR_RXNE)) {
    uint8_t data;
    data = usart_recv(WIFI_USART);

    // Temporarily disable interrupts, ring buffer is not thread safe.
    __disable_irq();
    ring_buffer_push(&wifi_rb, data);
    __enable_irq();
  }
}

// spwf_ProcessAsyncIndication any asynchronous communication from the WIFI
// module, indicating whenever a response is ready to be processed.
bool spwf_ProcessAsyncIndication(uint8_t *const buff, uint8_t data) {
  static uint16_t pos = 0;
  static uint8_t prev = '\0';

  buff[pos++] = data;

  // The beginning and the end of an asynchronous indication is marked by
  // "\r\n", by skipping the first two chars we look for pairs of "\r\n".
  if (pos > 2 && prev == '\r' && data == '\n') {
    spwf_DebugPrintBuffer(buff, '+');

    pos = 0;
    prev = '\0';
    return SPWF_PROCESS_COMPLETE;
  }

  prev = data;
  return WIFI_PROCESS_INCOMPLETE;
}

// spwf_ProcessATResponse processes the data in the provided at buffer and
// indicates whether or not the entire response has been received, the AT status
// is updated accordingly.
bool spwf_ProcessATResponse(ATState *at, uint8_t data) {
  at->buff[at->pos++] = data;

  // A response must always end at a "\r\n", by skipping len under the minimum
  // response length we avoid unecessary processing in the beginning.
  if (data == '\n' && at->buff[at->pos - 2] == '\r') {
    if (at->last_cr_lf != 0) {
      // Check for AT OK response (end), indicating a successfull HTTP request.
      if (strstr((const char *)at->last_cr_lf, "\r\nOK\r\n")) {
        spwf_DebugPrintBuffer(at->buff, '#');
        at->status = AT_STATUS_OK | AT_STATUS_READY;

        return SPWF_PROCESS_COMPLETE;
      }

      // Check for AT error response (end), indicating there was an error. We
      // check from last_cr_lf to ensure we get the full error message.
      if (strstr((const char *)at->last_cr_lf, "\r\nERROR")) {
        spwf_DebugPrintBuffer(at->buff, '!');
        at->status = AT_STATUS_ERROR | AT_STATUS_READY;

        return SPWF_PROCESS_COMPLETE;
      }
    }

    // Keep track of the current "\r\n" position.
    at->last_cr_lf = &at->buff[at->pos - 2];
  }

  return WIFI_PROCESS_INCOMPLETE;
}

// spwf_ProcessWIND consumes a buffer containing WIND and updates the state if
// a handled WIND ID is found.
bool spwf_ProcessWIND(SpwfState *state, uint8_t *const buff_ptr) {
  WINDType n = WIND_UNDEFINED;
  char *wind_ptr;

  wind_ptr = strstr((const char *)buff_ptr, "+WIND:");
  if (wind_ptr) {
    wind_ptr += 6;  // Skip over "+WIND:", next char is a digit.

    // We assume the indication ID is never greater than 99 (two digits).
    n = *wind_ptr++ - '0';  // Convert char to int
    if (*wind_ptr != ':') {
      n *= 10;               // First digit was a multiple of 10
      n += *wind_ptr - '0';  // Convert char to int
    }
  }

  switch (n) {
    case WIND_POWER_ON:
      // Reset WIFI state after power on.
      *state = SPWF_STATE_POWER_ON;
      break;
    case WIND_RESET:
      *state = SPWF_STATE_OFF;
      break;
    case WIND_CONSOLE_ACTIVE:
      *state |= SPWF_STATE_CONSOLE_ACTIVE;
      break;
    case WIND_WIFI_ASSOCIATED:
      *state |= SPWF_STATE_ASSOCIATED;
      break;
    case WIND_WIFI_JOINED:
      *state |= SPWF_STATE_JOINED;
      break;
    case WIND_WIFI_UP:
      *state |= SPWF_STATE_UP;
      break;
    case WIND_UNDEFINED:
      return false;
      break;
  }

  return true;
}

// wifi_ProcessCIND consumes a buffer containing CIND (custom indication) and
// enables remote management of the bttn.
bool wifi_ProcessCIND(Config *c, uint8_t *const buff_ptr) {
  static char text[120];
  CINDType n = CIND_UNDEF;
  char *cind_ptr;

  cind_ptr = strstr((const char *)buff_ptr, "+CIND:");
  if (cind_ptr) {
    cind_ptr += 6;  // Skip over "+CIND:", next char is a digit.

    // We assume the indication ID is never greater than 99 (two digits).
    n = *cind_ptr++ - '0';  // Convert char to int
    if (*cind_ptr != ':') {
      n *= 10;                 // First digit was a multiple of 10
      n += *cind_ptr++ - '0';  // Convert char to int
    }

    cind_ptr++;  // Skip over ':', leaving message.
  }

  switch (n) {
    case CIND_COMMIT_CONFIG:
      conf_RequestCommit(c);
      break;
    case CIND_SET_URL1:
      memset(&text[0], 0, 120);
      url_decode(&text[0], cind_ptr, URL_LENGTH);
      printf("Set URL1 to %s!\n", &text[0]);
      conf_Set(c, CONF_URL1, &text[0]);
      break;
    case CIND_SET_URL2:
      memset(&text[0], 0, 120);
      url_decode(&text[0], cind_ptr, URL_LENGTH);
      printf("Set URL2 to %s!\n", &text[0]);
      conf_Set(c, CONF_URL2, &text[0]);
      break;
    case CIND_UNDEF:
      return false;
      break;
  }

  return true;
}

// spwf_WaitState waits until the WIFI module is in specified state.
void spwf_WaitState(SpwfState state) {
  while ((spwf_state & state) == 0)
    ;
}

// spwf_ATReset resets the AT command state.
void spwf_ATReset(ATState *at) {
  memset(at->buff, 0, at->pos);
  at->status = AT_STATUS_CLEAR;
  at->last_cr_lf = 0;
  at->pos = 0;
}

// spwf_ATCmdWait waits until we recieve the entire AT response and
// returns true if there was no error, otherwise false.
bool spwf_ATCmdWait(void) {
  while ((spwf_at_state.status & AT_STATUS_READY) == 0)
    ;

  return (spwf_at_state.status & AT_STATUS_ERROR) == 0;
}

// spwf_ATCmd sends an AT command to the WIFI module without blocking, the
// response will still be available in the AT buffer once it is received.
void spwf_ATCmd(char *str) {
  spwf_WaitState(SPWF_STATE_CONSOLE_ACTIVE);
  spwf_ATReset(&spwf_at_state);

  spwf_SendString(str);

  // Change the recv type before sending the final "\r" to prevent potential
  // race conditions. This works because sending "A" is blocking and the WIFI
  // module queues all asynchronous indications.
  spwf_recv_state = RECV_AT_RESPONSE;

  spwf_SendString("\r");
}

// spwf_ATCmdBlocking sends an AT command to the WIFI module and blocks until
// it receives an OK or ERROR status. Returns true on OK and false on ERROR.
bool spwf_ATCmdBlocking(char *str) {
  spwf_ATCmd(str);
  return spwf_ATCmdWait();
}

// wifi_http_get_request performs a blocking HTTP GET request and returns the
// http status code returned by the server.
uint16_t wifi_http_get_request(char *url) {
  char req[URL_LENGTH];

  assert(strlen(url) <= URL_LENGTH);

  sprintf(&req[0], "AT+S.HTTPGET=%s", url);
  spwf_ATCmd(&req[0]);
  // We use fast processing here to quickly receive the response.
  spwf_at_state.status |= AT_STATUS_FAST_PROCESS;
  spwf_ATCmdWait();

  if ((spwf_at_state.status & AT_STATUS_OK) != 0) {
    return wifi_http_parse_status(spwf_at_state.buff);
  } else {
    return 0;
  }
}

// wifi_http_parse_status takes a http response buffer and tries to parse the
// status code from the http header, zero is returned when no status is found.
uint16_t wifi_http_parse_status(uint8_t *response) {
  uint16_t status = 0;
  char status_str[3];
  char *header_ptr;

  header_ptr = strstr((const char *)response, "HTTP/1.");
  if (header_ptr) {
    // The status code is the 9th-11th element of the header.
    // Example: "HTTP/1.0 200 OK"
    memcpy(&status_str, (header_ptr + 9), 3);
    status = atoi(&status_str[0]);
  }

  return status;
}

void wifi_get_ssid(char *dest, size_t len) {
  char *s;

  assert(len >= 32);

  spwf_ATCmdBlocking("AT+S.GCFG=wifi_ssid");

  s = strstr((const char *)spwf_at_state.buff, "#  wifi_ssid = ");
  if (s) {
    s += 15;  // Skip over "#  wifi_ssid = ".
    int i;
    for (i = 0; i < 32 && isxdigit(*s); i++) {  // Max lenght is 32.
      dest[i] = strtol(s, &s, 16);
      if (*s == ':') {
        s++;
      }
    }
  }
}

void wifi_CreateOpenBTTNPage(void) {
  char atCmd[26];  // AT+S.FSC=/index.html,0000\0

  memset(&atCmd[0], 0, sizeof(atCmd) / sizeof(atCmd[0]));
  snprintf(&atCmd[0], sizeof(atCmd) / sizeof(atCmd[0]),
           "AT+S.FSC=/index.html,%d", (int)index_html_len);

  printf("Sending: %s\n", atCmd);
  spwf_ATCmdBlocking(&atCmd[0]);  // Create file (AT+S.FSC).

  atCmd[7] = 'A';         // Modify command (AT+S.FSC -> AT+S.FSA).
  spwf_ATCmd(&atCmd[0]);  // Append to file.

  spwf_SendString((const char *)&index_html[0]);

  // Wait for response from WIFI module.
  spwf_ATCmdWait();
}

void wifi_StoreConfigJSON(ConfigData *data) {
  const char *url1 = (const char *)&data->url1[0];
  const char *url2 = (const char *)&data->url2[0];
  uint16_t len = strlen((const char *)&json_header[0]) + strlen(url1) +
                 strlen(url2) + 21;  // 21 = {"url1":"","url2":""}

  spwf_ATCmdBlocking("AT+S.FSD=/config.json");

  char atCmd[27];  // AT+S.FSC=/config.json,0000\0
  memset(&atCmd[0], 0, sizeof(atCmd) / sizeof(atCmd[0]));
  snprintf(atCmd, sizeof(atCmd) / sizeof(atCmd[0]), "AT+S.FSC=/config.json,%d",
           len);

  spwf_ATCmdBlocking(&atCmd[0]);  // Create file (AT+S.FSC).

  atCmd[7] = 'A';         // Modify command (AT+S.FSC -> AT+S.FSA).
  spwf_ATCmd(&atCmd[0]);  // Append to file.

  spwf_SendString((const char *)&json_header[0]);

  // Send file contents.
  spwf_SendString("{\"url1\":\"");
  spwf_SendString(url1);
  spwf_SendString("\",\"url2\":\"");
  spwf_SendString(url2);
  spwf_SendString("\"}");

  spwf_ATCmdWait();  // Wait for file to be created.
}

static void spwf_DebugPrintBuffer(uint8_t *const buff, uint8_t prefix) {
  uint8_t *ptr = &buff[0];

  usart_send_blocking(DEBUG_USART, prefix);
  usart_send_blocking(DEBUG_USART, '>');

  while (*ptr) {
    if (*ptr == '\r') {
      usart_send_blocking(DEBUG_USART, '\\');
      usart_send_blocking(DEBUG_USART, 'r');
    } else if (*ptr == '\n') {
      usart_send_blocking(DEBUG_USART, '\\');
      usart_send_blocking(DEBUG_USART, 'n');
    } else {
      usart_send_blocking(DEBUG_USART, *ptr);
    }
    ptr++;
  }

  usart_send_blocking(DEBUG_USART, '\r');
  usart_send_blocking(DEBUG_USART, '\n');
}

unsigned char index_html[] = {
    0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x20, 0x32, 0x30, 0x30,
    0x20, 0x4f, 0x4b, 0x0a, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x3a, 0x20,
    0x4f, 0x70, 0x65, 0x6e, 0x42, 0x54, 0x54, 0x4e, 0x0a, 0x43, 0x6f, 0x6e,
    0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x63, 0x6c, 0x6f,
    0x73, 0x65, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54,
    0x79, 0x70, 0x65, 0x3a, 0x20, 0x74, 0x65, 0x78, 0x74, 0x2f, 0x68, 0x74,
    0x6d, 0x6c, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x4c,
    0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x31, 0x37, 0x33, 0x31, 0x0a,
    0x0a, 0x0a, 0x3c, 0x21, 0x44, 0x4f, 0x43, 0x54, 0x59, 0x50, 0x45, 0x20,
    0x68, 0x74, 0x6d, 0x6c, 0x3e, 0x0a, 0x3c, 0x68, 0x74, 0x6d, 0x6c, 0x3e,
    0x0a, 0x3c, 0x68, 0x65, 0x61, 0x64, 0x3e, 0x0a, 0x09, 0x3c, 0x74, 0x69,
    0x74, 0x6c, 0x65, 0x3e, 0x4f, 0x70, 0x65, 0x6e, 0x42, 0x54, 0x54, 0x4e,
    0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x3e, 0x0a, 0x3c, 0x2f, 0x68,
    0x65, 0x61, 0x64, 0x3e, 0x0a, 0x3c, 0x62, 0x6f, 0x64, 0x79, 0x3e, 0x0a,
    0x09, 0x3c, 0x68, 0x31, 0x3e, 0x4f, 0x70, 0x65, 0x6e, 0x42, 0x54, 0x54,
    0x4e, 0x3c, 0x2f, 0x68, 0x31, 0x3e, 0x0a, 0x09, 0x3c, 0x66, 0x6f, 0x72,
    0x6d, 0x3e, 0x0a, 0x09, 0x09, 0x55, 0x52, 0x4c, 0x3a, 0x3c, 0x62, 0x72,
    0x3e, 0x0a, 0x09, 0x09, 0x3c, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x20, 0x69,
    0x64, 0x3d, 0x22, 0x75, 0x72, 0x6c, 0x31, 0x22, 0x20, 0x76, 0x61, 0x6c,
    0x75, 0x65, 0x3d, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x22,
    0x3e, 0x3c, 0x62, 0x72, 0x3e, 0x20, 0x4c, 0x6f, 0x6e, 0x67, 0x20, 0x70,
    0x72, 0x65, 0x73, 0x73, 0x20, 0x55, 0x52, 0x4c, 0x3a, 0x3c, 0x62, 0x72,
    0x3e, 0x0a, 0x09, 0x09, 0x3c, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x20, 0x69,
    0x64, 0x3d, 0x22, 0x75, 0x72, 0x6c, 0x32, 0x22, 0x20, 0x76, 0x61, 0x6c,
    0x75, 0x65, 0x3d, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x22,
    0x3e, 0x3c, 0x62, 0x72, 0x3e, 0x0a, 0x09, 0x09, 0x3c, 0x69, 0x6e, 0x70,
    0x75, 0x74, 0x20, 0x69, 0x64, 0x3d, 0x22, 0x61, 0x70, 0x70, 0x6c, 0x79,
    0x22, 0x20, 0x74, 0x79, 0x70, 0x65, 0x3d, 0x22, 0x62, 0x75, 0x74, 0x74,
    0x6f, 0x6e, 0x22, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3d, 0x22, 0x41,
    0x70, 0x70, 0x6c, 0x79, 0x20, 0x28, 0x4d, 0x65, 0x6d, 0x6f, 0x72, 0x79,
    0x29, 0x22, 0x3e, 0x20, 0x3c, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x20, 0x69,
    0x64, 0x3d, 0x22, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x22, 0x20, 0x74,
    0x79, 0x70, 0x65, 0x3d, 0x22, 0x62, 0x75, 0x74, 0x74, 0x6f, 0x6e, 0x22,
    0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3d, 0x22, 0x43, 0x6f, 0x6d, 0x6d,
    0x69, 0x74, 0x20, 0x28, 0x45, 0x45, 0x50, 0x52, 0x4f, 0x4d, 0x29, 0x22,
    0x3e, 0x0a, 0x09, 0x3c, 0x2f, 0x66, 0x6f, 0x72, 0x6d, 0x3e, 0x0a, 0x09,
    0x3c, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3e, 0x27, 0x75, 0x73, 0x65,
    0x20, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x27, 0x3b, 0x63, 0x6f, 0x6e,
    0x73, 0x74, 0x20, 0x75, 0x72, 0x6c, 0x3d, 0x27, 0x2f, 0x6f, 0x75, 0x74,
    0x70, 0x75, 0x74, 0x2e, 0x63, 0x67, 0x69, 0x3f, 0x74, 0x65, 0x78, 0x74,
    0x3d, 0x27, 0x3b, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x20, 0x70, 0x61, 0x72,
    0x73, 0x65, 0x72, 0x3d, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
    0x2e, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x45, 0x6c, 0x65, 0x6d, 0x65,
    0x6e, 0x74, 0x28, 0x27, 0x61, 0x27, 0x29, 0x3b, 0x66, 0x65, 0x74, 0x63,
    0x68, 0x28, 0x27, 0x2e, 0x2f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e,
    0x6a, 0x73, 0x6f, 0x6e, 0x27, 0x29, 0x2e, 0x74, 0x68, 0x65, 0x6e, 0x28,
    0x72, 0x3d, 0x3e, 0x72, 0x2e, 0x6a, 0x73, 0x6f, 0x6e, 0x28, 0x29, 0x29,
    0x2e, 0x74, 0x68, 0x65, 0x6e, 0x28, 0x73, 0x3d, 0x3e, 0x7b, 0x66, 0x6f,
    0x72, 0x28, 0x6c, 0x65, 0x74, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x69, 0x6e,
    0x20, 0x73, 0x29, 0x7b, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
    0x2e, 0x67, 0x65, 0x74, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x42,
    0x79, 0x49, 0x64, 0x28, 0x6b, 0x65, 0x79, 0x29, 0x2e, 0x76, 0x61, 0x6c,
    0x75, 0x65, 0x3d, 0x64, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x41, 0x54, 0x55,
    0x52, 0x4c, 0x28, 0x73, 0x5b, 0x6b, 0x65, 0x79, 0x5d, 0x29, 0x7d, 0x7d,
    0x29, 0x3b, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x61,
    0x64, 0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x65,
    0x6e, 0x65, 0x72, 0x28, 0x27, 0x44, 0x4f, 0x4d, 0x43, 0x6f, 0x6e, 0x74,
    0x65, 0x6e, 0x74, 0x4c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x27, 0x2c, 0x28,
    0x29, 0x3d, 0x3e, 0x7b, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
    0x2e, 0x67, 0x65, 0x74, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x42,
    0x79, 0x49, 0x64, 0x28, 0x27, 0x61, 0x70, 0x70, 0x6c, 0x79, 0x27, 0x29,
    0x2e, 0x61, 0x64, 0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x4c, 0x69, 0x73,
    0x74, 0x65, 0x6e, 0x65, 0x72, 0x28, 0x27, 0x63, 0x6c, 0x69, 0x63, 0x6b,
    0x27, 0x2c, 0x63, 0x6c, 0x69, 0x63, 0x6b, 0x28, 0x66, 0x61, 0x6c, 0x73,
    0x65, 0x29, 0x29, 0x3b, 0x64, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
    0x2e, 0x67, 0x65, 0x74, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x42,
    0x79, 0x49, 0x64, 0x28, 0x27, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x27,
    0x29, 0x2e, 0x61, 0x64, 0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x4c, 0x69,
    0x73, 0x74, 0x65, 0x6e, 0x65, 0x72, 0x28, 0x27, 0x63, 0x6c, 0x69, 0x63,
    0x6b, 0x27, 0x2c, 0x63, 0x6c, 0x69, 0x63, 0x6b, 0x28, 0x74, 0x72, 0x75,
    0x65, 0x29, 0x29, 0x3b, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e,
    0x20, 0x63, 0x6c, 0x69, 0x63, 0x6b, 0x28, 0x63, 0x6f, 0x6d, 0x6d, 0x69,
    0x74, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x29, 0x7b, 0x72, 0x65,
    0x74, 0x75, 0x72, 0x6e, 0x20, 0x65, 0x3d, 0x3e, 0x7b, 0x65, 0x2e, 0x70,
    0x72, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c,
    0x74, 0x28, 0x29, 0x3b, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x20, 0x75, 0x72,
    0x6c, 0x31, 0x3d, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x49, 0x4e,
    0x44, 0x28, 0x31, 0x2c, 0x61, 0x74, 0x55, 0x52, 0x4c, 0x28, 0x64, 0x6f,
    0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x67, 0x65, 0x74, 0x45, 0x6c,
    0x65, 0x6d, 0x65, 0x6e, 0x74, 0x42, 0x79, 0x49, 0x64, 0x28, 0x27, 0x75,
    0x72, 0x6c, 0x31, 0x27, 0x29, 0x2e, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x29,
    0x29, 0x3b, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x20, 0x75, 0x72, 0x6c, 0x32,
    0x3d, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x49, 0x4e, 0x44, 0x28,
    0x32, 0x2c, 0x61, 0x74, 0x55, 0x52, 0x4c, 0x28, 0x64, 0x6f, 0x63, 0x75,
    0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x67, 0x65, 0x74, 0x45, 0x6c, 0x65, 0x6d,
    0x65, 0x6e, 0x74, 0x42, 0x79, 0x49, 0x64, 0x28, 0x27, 0x75, 0x72, 0x6c,
    0x32, 0x27, 0x29, 0x2e, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x29, 0x29, 0x3b,
    0x63, 0x6f, 0x6e, 0x73, 0x74, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74,
    0x3d, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x49, 0x4e, 0x44, 0x28,
    0x30, 0x2c, 0x27, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x20, 0x63, 0x6f,
    0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x27,
    0x29, 0x3b, 0x66, 0x65, 0x74, 0x63, 0x68, 0x28, 0x75, 0x72, 0x6c, 0x31,
    0x29, 0x2e, 0x74, 0x68, 0x65, 0x6e, 0x28, 0x28, 0x29, 0x3d, 0x3e, 0x66,
    0x65, 0x74, 0x63, 0x68, 0x28, 0x75, 0x72, 0x6c, 0x32, 0x29, 0x29, 0x2e,
    0x74, 0x68, 0x65, 0x6e, 0x28, 0x28, 0x29, 0x3d, 0x3e, 0x63, 0x6f, 0x6d,
    0x6d, 0x69, 0x74, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x3f, 0x66,
    0x65, 0x74, 0x63, 0x68, 0x28, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x29,
    0x3a, 0x27, 0x27, 0x29, 0x2e, 0x74, 0x68, 0x65, 0x6e, 0x28, 0x28, 0x29,
    0x3d, 0x3e, 0x63, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x2e, 0x6c, 0x6f,
    0x67, 0x28, 0x27, 0x53, 0x61, 0x76, 0x65, 0x64, 0x21, 0x27, 0x29, 0x29,
    0x2e, 0x63, 0x61, 0x74, 0x63, 0x68, 0x28, 0x72, 0x3d, 0x3e, 0x63, 0x6f,
    0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x2e, 0x6c, 0x6f, 0x67, 0x28, 0x72, 0x29,
    0x29, 0x7d, 0x7d, 0x7d, 0x29, 0x3b, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x61, 0x74, 0x55, 0x52, 0x4c, 0x28, 0x75, 0x72, 0x6c,
    0x29, 0x7b, 0x69, 0x66, 0x28, 0x21, 0x75, 0x72, 0x6c, 0x2e, 0x6d, 0x61,
    0x74, 0x63, 0x68, 0x28, 0x2f, 0x5e, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3f,
    0x3a, 0x5c, 0x2f, 0x5c, 0x2f, 0x2f, 0x29, 0x29, 0x7b, 0x75, 0x72, 0x6c,
    0x3d, 0x27, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x27, 0x2b, 0x75,
    0x72, 0x6c, 0x7d, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2e, 0x68, 0x72,
    0x65, 0x66, 0x3d, 0x75, 0x72, 0x6c, 0x3b, 0x6c, 0x65, 0x74, 0x20, 0x70,
    0x6f, 0x72, 0x74, 0x3d, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2e, 0x70,
    0x6f, 0x72, 0x74, 0x3b, 0x69, 0x66, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65,
    0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x3d, 0x3d,
    0x3d, 0x27, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x27, 0x26, 0x26, 0x21,
    0x70, 0x6f, 0x72, 0x74, 0x29, 0x7b, 0x70, 0x6f, 0x72, 0x74, 0x3d, 0x34,
    0x34, 0x33, 0x7d, 0x6c, 0x65, 0x74, 0x20, 0x6e, 0x65, 0x77, 0x55, 0x52,
    0x4c, 0x3d, 0x60, 0x24, 0x7b, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2e,
    0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x7d, 0x2c, 0x24, 0x7b,
    0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x61, 0x74, 0x68, 0x6e,
    0x61, 0x6d, 0x65, 0x7d, 0x24, 0x7b, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72,
    0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x7d, 0x2c, 0x24, 0x7b, 0x70,
    0x6f, 0x72, 0x74, 0x7d, 0x60, 0x3b, 0x69, 0x66, 0x28, 0x6e, 0x65, 0x77,
    0x55, 0x52, 0x4c, 0x2e, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3e, 0x31,
    0x30, 0x30, 0x29, 0x7b, 0x74, 0x68, 0x72, 0x6f, 0x77, 0x20, 0x6e, 0x65,
    0x77, 0x20, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x28, 0x27, 0x6d, 0x61, 0x78,
    0x20, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x27, 0x29, 0x7d, 0x72, 0x65,
    0x74, 0x75, 0x72, 0x6e, 0x20, 0x6e, 0x65, 0x77, 0x55, 0x52, 0x4c, 0x7d,
    0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x64, 0x65, 0x63,
    0x6f, 0x64, 0x65, 0x41, 0x54, 0x55, 0x52, 0x4c, 0x28, 0x75, 0x72, 0x6c,
    0x29, 0x7b, 0x6c, 0x65, 0x74, 0x5b, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e,
    0x2c, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2c, 0x70, 0x6f, 0x72, 0x74,
    0x5d, 0x3d, 0x75, 0x72, 0x6c, 0x2e, 0x73, 0x70, 0x6c, 0x69, 0x74, 0x28,
    0x27, 0x2c, 0x27, 0x29, 0x3b, 0x69, 0x66, 0x28, 0x70, 0x6f, 0x72, 0x74,
    0x29, 0x7b, 0x70, 0x6f, 0x72, 0x74, 0x3d, 0x27, 0x3a, 0x27, 0x2b, 0x70,
    0x6f, 0x72, 0x74, 0x7d, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x27, 0x68,
    0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x27, 0x2b, 0x64, 0x6f, 0x6d, 0x61,
    0x69, 0x6e, 0x2b, 0x70, 0x6f, 0x72, 0x74, 0x2b, 0x73, 0x65, 0x61, 0x72,
    0x63, 0x68, 0x7d, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x43, 0x49, 0x4e, 0x44, 0x28, 0x69,
    0x64, 0x2c, 0x74, 0x65, 0x78, 0x74, 0x29, 0x7b, 0x63, 0x6f, 0x6e, 0x73,
    0x74, 0x20, 0x63, 0x69, 0x6e, 0x64, 0x3d, 0x60, 0x2b, 0x43, 0x49, 0x4e,
    0x44, 0x3a, 0x24, 0x7b, 0x69, 0x64, 0x7d, 0x3a, 0x24, 0x7b, 0x65, 0x6e,
    0x63, 0x6f, 0x64, 0x65, 0x55, 0x52, 0x49, 0x43, 0x6f, 0x6d, 0x70, 0x6f,
    0x6e, 0x65, 0x6e, 0x74, 0x28, 0x74, 0x65, 0x78, 0x74, 0x29, 0x7d, 0x60,
    0x3b, 0x69, 0x66, 0x28, 0x63, 0x69, 0x6e, 0x64, 0x2e, 0x6c, 0x65, 0x6e,
    0x67, 0x74, 0x68, 0x3e, 0x31, 0x32, 0x30, 0x29, 0x7b, 0x74, 0x68, 0x72,
    0x6f, 0x77, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x45, 0x72, 0x72, 0x6f, 0x72,
    0x28, 0x27, 0x6d, 0x61, 0x78, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65,
    0x64, 0x20, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x27, 0x29, 0x7d, 0x72,
    0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x75, 0x72, 0x6c, 0x2b, 0x63, 0x69,
    0x6e, 0x64, 0x7d, 0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3e,
    0x0a, 0x3c, 0x2f, 0x62, 0x6f, 0x64, 0x79, 0x3e, 0x0a, 0x3c, 0x2f, 0x68,
    0x74, 0x6d, 0x6c, 0x3e, 0x0a};
unsigned int index_html_len = 1829;

unsigned char json_header[] =
    "HTTP/1.0 200 OK\n"
    "Server: OpenBTTN\n"
    "Connection: close\n"
    "Content-Type: application/json\n\n\n";
